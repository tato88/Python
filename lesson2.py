# написать функцию на замыкания которая будет в себе хранить лист дел, вам нужно реализовать два метода
# - первый записывает в эту переменную запись
# - второй возвращает все записи
#
# запишите 5 тудушек
# и выведете все


# def notebook():
#     todo_list: list[str] = []
#
#     def add_todo(todo: str) -> list:
#         todo_list.append(todo)
#         return todo_list
#
#     def get_all():
#         print(todo_list)
#
#     return add_todo
#
#
# book1 = notebook()
# book2 = notebook()
#
# print(book1('wake up'))
# print(book1('eat'))
# print(book2('sleep'))
# print(book2('sleep'))
# print(book2('sleep'))
# print(book1('work'))
# print(book1('relax'))
# print(book1('sleep'))
# print(book2('sleep'))
# print(book2('sleep'))

######################################################################################################################
######################################################################################################################
######################################################################################################################

# 3) создать функцию которая будет возвращать сумму разрядов числа в виде строки (тоже с типизацией)
#
# Пример:
#
# expanded_form(12) # return '10 + 2'
# expanded_form(42) # return '40 + 2'
# expanded_form(70304) # return '70000 + 300 + 4'

# def sum_raz(a: int) -> str:
#     n: str = str(a)
#     array: list = []
#     summa: str = ''
#
#     for i, v in enumerate(n):
#         x: str = v + '0' * ((len(n)) - (i + 1))
#         array.append(x)
#         if x != '0' and int(x) > 0:
#             summa += '+' + x
#     print(array)
#     return summa
#
#
# print(sum_raz(5315300))


######################################################################################################################
######################################################################################################################
######################################################################################################################

# создать декоратор который будет считать сколько раз была запущена функция и будет выводит это значение после каждого запуска функции

# def decor(func):
#     count = 1
#
#     def inner():
#         nonlocal count
#         func()
#         print(count)
#         print('--------------------')
#         count += 1
#         return count
#     return inner
#
#
# @decor
# def greeting():
#     print('Function')
#
#
# greeting()
# greeting()
# greeting()


######################################################################################################################
######################################################################################################################
######################################################################################################################

# вивести послідовність Фібоначі, кількість вказана в знінній,
#   наприклад: x = 10 -> 1 1 2 3 5 8 13 21 34 55
#   (число з послідовності - це сума попередніх двох чисел)

# a = 10
#
#
# def fibo(x):
#     array = [0, 1]
#     for i in range(x-2):
#         print(array[-1], array[-2])
#         array.append(array[-2] + array[-1])
#
#     return array
#
#
# print(fibo(a))


######################################################################################################################
######################################################################################################################
######################################################################################################################

# порахувати кількість парних і непарних цифр числа,
#   наприклад: х = 225688 -> п = 5, н = 1;
#          х = 33294 -> п = 2, н = 3

# num = 22568822005688
#
#
# def par_nepar(x):
#     str_num = str(x)
#     count_par = 0
#     count_nepar = 0
#     count_zero = 0
#     for i in str_num:
#         if int(i) == 0:
#             count_zero += 1
#         elif int(i) % 2 == 0:
#             count_par += 1
#         elif int(i) % 2 == 1:
#             count_nepar += 1
#     return (f'парні: {count_par}, непарні: {count_nepar}, zero:{count_zero}')
#
#
# print(par_nepar(num))

######################################################################################################################
######################################################################################################################
######################################################################################################################


# прога, що
# виводить
# кількість
# кожного
# символа
# з
# введеної
# строки,
# наприклад:
# st = 'as 23 fdfdg544'  # введена строка
#
# 'a' -> 1  # вивело в консолі
# 's' -> 1
# ' ' -> 2
# '2' -> 1
# '3' -> 1
# 'f' -> 2
# 'd' -> 2
# 'g' -> 1
# '5' -> 1
# '4' -> 2


# st = 'as 23 fdfdg5442'
#
#
# def calc_symbols(string):
#     array = []
#     for i in string:
#         count = 0
#         for j in string:
#             if i == j:
#                 count += 1
#         array.append({i: count})
#     return array
#
#
# print(calc_symbols(st))


######################################################################################################################
######################################################################################################################
######################################################################################################################

# генерируем лист с непарных чисел в порядке возрастания [1,3,5,7,9.....n]
# задача сделать c него лист листов такого плана:
#
# [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]  => [ [1], [3,5], [7,9,11], [13,15,17,19] ]
# [1, 3, 5, 7, 9, 11] => [[1], [3, 5], [7, 9, 11]]
# [1, 3, 5, 7, 9]  => [ [1], [3,5], [7,9]]
# [1, 3, 5, 7, 9, 11, 13]  => [[1], [3, 5], [7, 9, 11], [13]]


# n = 22
# l = []
# for i in range(n * 2):
#     if i % 2 == 1:
#         l.append(i)
#
#
# def l_in_l(random_list):
#     list_list = []
#     z = 0
#     s = 1
#     step = 1
#     print(random_list)
#     for i in random_list:
#         print(z, s)
#         test = random_list[z:s]
#         list_list.append(test)
#         z = s
#         step += 1
#         s += step
#     return list_list
#
#
# print(l_in_l(l))
